import "Operations.eol";

pre {
	var gaexechost = "GaExecHost";
	var gastep = "GaStep";
	var gaworkload = "GaWorkloadEvent";
	var entryCounter : Integer = 0;
	var allBes = UML!BehaviorExecutionSpecification.all;
}

post {

}

rule Model2Schema 
	transform uml: UML!Model
	to lqn: LQN!LqnModelType
	{
		guard: uml.name <> "PrimitiveTypes"
		// "Convert nodes and actors to processors...".println();
		var nodes = UML!Node.all.equivalent();
		var actors = UML!Actor.all.equivalent("Actor2Processor");

		lqn.name = uml.name;
		lqn.processor.addAll(nodes);
		lqn.processor.addAll(actors);
		
		UML!MessageOccurrenceSpecification.all.size().println();
	}

rule Node2Processor
	transform node: UML!Node
	to proc: LQN!ProcessorType 
	{	
		/* 
		 * The guard filters the nodes:
		 * - Nodes thet are not stereotyped with <<GaExecHost>>;
		 * - A <<GaExecHost>> Node without deployments
         * - A <<GaExecHost>> Node deploying elements that are not interacting
		 */
		guard {
			/* 
			 * Gets the artifacts deployed on this Node
			 * Selects the artifacts that are interacting through their manifested component
			 */
			var components = node.getDeployed().select(i | i.isInteracting());
			/* 
			 * The transformation considers nodes stereotyped with 
		     * <<GaExecHost>> and deploying interacting components
             */
			return node.isStereotypeApplied(gaexechost) 
				and components.notEmpty();
		}
		// ("Create processor for node: " + node.name).println();
		/* 
		 * Retrieves the components deployed on the current node 
		 * and interacting in a scenario
		 */
		var components = node.getDeployed().select(i | i.isInteracting());
		var operations = components.collect(c | c.getOperations()).flatten;

        proc.multiplicity = "1".asBigInteger();
		proc.name = node.name;
		proc.task = operations.equivalent("Operation2Task");
	}
	
rule Actor2Processor
	transform actor: UML!Actor
	to proc: LQN!ProcessorType
	{
		guard {
			var lifelines = UML!Lifeline.all().select(i | i.represents.type = actor);
			// an actor is transformed if it interacts and has a single lifeline
			return actor.isInteracting();// and lifelines.size() = 1;
		}

//		("Create processor for actor: " + actor.name).println();
	    var lifelines = UML!Lifeline.all.select(l | l.represents.type = actor);
		
//		("Lifelines for actor '" + actor.name + "' found: " + lifelines.size()).println();
		
		proc.name = actor.name;
		for(lf in lifelines){
		    var interaction = lf.getInteraction();
		    var task = interaction.equivalent("Interaction2Task");
		    proc.task.add(task);
		}
	}


/**
  * This rule transforms an interaction to a task.
  * The interaction is required to contain a lifeline that has the stereotype "GaWorkloadEvent"
  * The "pattern" attribute needs to be applied to the lifeline to get the workload for the task.
  * The BES of the Lifeline get transformed to an EntryType
*/
rule Interaction2Task
	transform interaction: UML!Interaction
	to task: LQN!TaskType
	{
		guard {
            var lifelines = interaction.getLifelines();

            if(lifelines.isEmpty()) {
                return false;
            }
            
            return lifelines->atLeastNMatch(lf : UML!Lifeline | lf.isStereotypeApplied(gaworkload), 1 );

		}
		("Create task for interaction: " + interaction.name).println();
		
        // For each interaction there must be only one lifeline stereotyped with gaworkload
        var lifeline = interaction.getLifelines() -> selectOne(lf | lf.isStereotypeApplied(gaworkload));

	    var beses = lifeline.collect(i | i.getElements("BehaviorExecutionSpecification")).flatten;
	    var workload = lifeline.getWorkload();
	    task.name = interaction.getOwner().getName() + "_job_class_" ;
	    task.entry = beses.equivalent("BES2Entry");
	    	    
	    if(workload[0] = "closed"){
	    	task.scheduling = LQN!TaskSchedulingType#ref;
	    	task.multiplicity = workload[1];
	    } else {
	    	for(entry in task.entry) {
	    		entry.openArrivalRate = workload[1];	    	
	    	}
	    }
	}

rule Operation2Task
	transform op: UML!Operation
	to task: LQN!TaskType
	{
		guard {
			/**
			 * The guard filters all the operations their 
			 * components are not interacting and
			 * not deployed on a Node
			 **/
			 var component = op.getOwner();
			 if (not component.isDefined()) {
			 	throw "There is no owning Component for Operation: " + op.name;
			 }
			 if(component.getArtifacts().isEmpty())
				throw "Component " + component.name + 
					" is not represented by any Artifact";
			 return component.isInteracting();
		}
		// ("Create task for component: " + component.name).println();
	
		var component = op.getOwner();
		var besName = op.getReference("BES");
		var bes = allBes.selectOne(b | b.name == besName);
		var entries = Sequence{bes.equivalent("BES2Entry")};
		
		
		"besName: ".print();
		besName.println();
		"bes: ".print();
		bes.println();
		"entries: ".print();
		entries.println();
		
		/*
		 * multiplicity of a task is given by the number of artifacts
		 * representing it
		 * TODO: Why? --> does this mean that more processors are available for the queue?
		 */
		var artifacts = component.getArtifacts();
		var multiplicity = artifacts.size().asString();
							
		task.name = op.name;
		task.entry = entries;
		task.multiplicity = multiplicity.asBigInteger();
	}
	
rule BES2Entry
	transform bes: UML!BehaviorExecutionSpecification // BES
	to entry: LQN!EntryType
	{	
		guard {
			/**
			 * A BES is excluded from the transformation if:
			 * It doesn't start with a UML!MessageOccurrenceSpecification;
			 * It doesn't end with a UML!MessageOccurrenceSpecification;
			 * It is not bound to a lifeline;
			 */
			 
			if(not (bes.isWellFormed())) {
				return false;
			}
			// A BES should belong to a single and existing Lifeline
			return bes.covered.first.isDefined();
		}
		// ("Create Entry for BehaviorExecutionSpecification: " + bes.name).println();
		
			
		entry.name = bes.name;
		entry.type = LQN!TypeType#PH1PH2;
		entry.entryPhaseActivities = new LQN!PhaseActivities;
 		entry.entryPhaseActivities.activity = Sequence{bes.equivalent("Bes2Activity")};
	}
	
@lazy
rule Bes2Activity
	transform bes: UML!BehaviorExecutionSpecification // BES
	to act: LQN!ActivityPhasesType 
	{
		act.name = bes.name;
		act.phase = "1".asBigInteger();
		
		// Activity host-demand-mean
		var execTime = bes.getValue(gastep, "execTime");
		var rep = bes.getValue(gastep, "rep");
		var hostDemandMean = "1.0";

		if(execTime.isDefined()) {
			hostDemandMean = execTime.asDouble() * rep.asDouble();
		}
		act.hostDemandMean = hostDemandMean + "";
		
		var messages = bes.getMessages();
		// Gets only the messages that are sent
		messages = messages.select(i | i.isSend() and i.message.messageSort <> UML!MessageSort#reply);

		"messages: ".print();
		messages.println();
		
		// Calls from the Activity
		// TODO: separate between synch and asynch
		if (not messages.isEmpty()) {
			var calls = messages.equivalent("Message2Request");
			var callsFiltered = new Sequence();
			// this is the loop recognition for the calls
			// For each call that has a dublicate the repetition is increased
			for (c in calls) {
				var cfList = callsFiltered.select(cf | c.dest == cf.dest);
				if (cfList.size() > 1) {
					throw "There should be only one of a kind in the list 'cfList' found: " + cfList;
				}
				if (cfList.size() == 0) {
					callsFiltered.add(c);
					continue;
				}
				var cf = cfList.first();
				cf.callsMean = (cf.callsMean.asBigInteger() + c.callsMean.asBigInteger()) + "";
			}
			act.synchCall = callsFiltered;
		}
	}
	

@lazy
rule Message2Request
	transform msgo: UML!MessageOccurrenceSpecification // MOS
	to call: LQN!ActivityMakingCallType
	{
		guard {
			return msgo.isSend(); // this asks if the MOS is at the sending (lifeline) end of the message and not at the receiving (lifeline) end.
		}

		("Create ActivityMakingCallType for MessageOccurrenceSpecification: " + msgo.name).println();

		var message = msgo.message;
		var rep = bes.getValue(gastep, "rep");

		// This is the sequence of steps that is followed to find the BES that is started by the message associated with the msgo (or MOS):
		//    Message ---MessageEnd--> Lifeline --find all--> BESes --filter with Message--> BES (that is started by the Message)
		
		// get lifeline that the message targets
		var lifeline = message.receiveEvent.covered;
		// Gets the BESes from the lifeline that is covered by the message
		var lbes = lifeline.first.getElements("BehaviorExecutionSpecification");
		// Gets the BES that is the one that the message targets
		var lbes2 = lbes.selectOne(i | i.start == message.receiveEvent and i.finish.isTypeOf(MessageOccurrenceSpecification));

		call.dest = lbes2.name;
		call.callsMean = lbes2.getValue(gastep, "rep");
	}
	
	
